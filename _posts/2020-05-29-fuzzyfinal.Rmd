---
title: "SQL: Data Analytics For an Online Retailer Part 2"
date: "2020-05-29"
tags: [MySQL, MySQL Workbench, R Studio, R Markdown, RMariaDB]
excerpt: "Analyzing Channel Portfolio Management, Analyzing Business Patterns and Seasonality, Product Analysis"
mathjax: true
output: github_document
---

## Background

You may find the first part of this project on the home page.

I completed Maven Analytic's 'Advanced SQL + MySQL for Analytics & Business Intelligence' course. During this course there were 2 projects we were to complete to get simulated experience with not only the advanced SQL skills taught in the body of the course but also in the context of a business setting. The relational database, mavenfuzzyfactory, was imported into MySQL Workbench and used throughout the course. 

I played the role of a data analyst for a new online retailer, Maven Fuzzy Factory. They make stuffed animals. In this database, we had info dealing with website sessions, website pageviews, products, orders, order items, and refunds. The board of directors and executives needed answers to some questions to see if the business was growing and doing so efficiently.

The analysis was performed in MySQL Workbench and the reporting as follows was done using an R Markdown file in R Studio by connecting to the database using the `RMariaDB` R Package and using SQL chunks.

**SQL Concepts Implemented**

* The Big 6: `SELECT`-->`FROM`-->`WHERE`-->`GROUP BY`-->`HAVING`-->`ORDER BY`
* Aggregation (`COUNT`, `SUM`, `MAX`, ect.)
* `LEFT JOIN`
* `VIEW`'s and Subqueries
* `CASE` and `COUNT(DISTINCT CASE WHEN...)` (count-case pivoting)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RMariaDB)
library(knitr)
# Connect to MySQL Database
db <- dbConnect(RMariaDB::MariaDB(), user='R_fuzzy',password="Mathematic$1998", dbname='mavenfuzzyfactory', host='localhost',bigint = "numeric")
# List the tables in our relational database
dbListTables(db)
```

## Final Project

**Note: These queries will show only a limited number of rows for the sake of seeing the structure of the output. They are not the full result of the queries in terms of number of rows**

Some of the types of inquiries and requests I recieved involve:

* Analyzing Channel Portfolio Management (Analyzing Channel Portfolios, Comparing Channel Characteristics, Cross-Channel Bid Optimization, Analyzing Channel Portfolio Trends, Brand Driven Traffic, Analyzing Direct Traffic)

* Analyzing Business Patterns and Seasonality

* Product Analysis (Product-Level Sales Analysis, Analyzing Product Launches, Product-Level Website Pathing, Building Product-Level Conversion Funnels, Cross-Sell Analysis, Product Portfolio Expansion, Product Refund Rates)

These are the questions that I was requested to get answers on for the midterm project, along with the code I wrote and its output.

## Objective 1: Show off volume growth 

**Pull overall website session volume and order volume, trended by quarter, for the life of the business**

```{sql connection=db, max.print=30}
SELECT
DATE_FORMAT(website_sessions.created_at, '%Y/%m') AS yr_mo,

COUNT(orders.order_id) AS orders_volume,
COUNT(website_sessions.website_session_id) AS sessions_volume

FROM website_sessions
LEFT JOIN orders
ON orders.website_session_id = website_sessions.website_session_id
GROUP BY 1;
```
We see consistent growth in both order and website session volume, a positive sign for growth of the business.




## Objective 2: Showcase efficiency improvements 

**Show quarterly figures for session to order CVR, revenue per order, and revenue per session**

```{sql, connection=db, max.print = 30}
SELECT
YEAR(website_sessions.created_at) AS yr,
QUARTER(website_sessions.created_at) AS qtr,

COUNT(orders.order_id)/COUNT(website_sessions.website_session_id) AS CVR,
AVG(orders.price_usd) AS AOV,
SUM(orders.price_usd)/COUNT(website_sessions.website_session_id) AS rev_per_session

FROM website_sessions
LEFT JOIN orders
ON orders.website_session_id = website_sessions.website_session_id
GROUP BY 1,2;
```
Not only are orders and sessions doing well by volume, but we see an improvement in efficiency as well. Session-to-order conversion rates are on a strong upward trend, going from only 3% of sessions resulting in an order up to north of 8% within 2 years. Similarly, average order value jumps from \$49 to north of \$62 per order. Revenue per session goes from only \$1.58 to \$5.29 which is a remarkable jump. This indicates that individuals are buying more frequently and spending more money when they do buy products.


## Objective 3: Show how certain web channels have grown 

**Pull quarterly view of orders from 'gsearch nonbrand', 'bsearch nonbrand', 'brand search overall', 'organic search', and 'direct type-in'**

(Note: If it is a 'bsearch' or 'gsearch' session, then they got it via search engine by clicking on a paid advertisement. If it was through a search engine but instead of a paid advertisement they clicked on a normal link, then that is an 'organic session'. If they directly typed in the website's http address then it is a 'direct session'.)

```{sql, connection=db, max.print = 30}
SELECT
YEAR(website_sessions.created_at) AS yr,
QUARTER(website_sessions.created_at) AS qtr,

COUNT(CASE WHEN website_sessions.utm_source = 'gsearch' AND website_sessions.utm_campaign = 'nonbrand' THEN orders.order_id ELSE NULL END) AS g_nonbrand_orders,
COUNT(CASE WHEN website_sessions.utm_source = 'bsearch' AND website_sessions.utm_campaign = 'nonbrand' THEN orders.order_id ELSE NULL END) AS b_nonbrand_orders,
COUNT(CASE WHEN website_sessions.utm_campaign = 'brand' THEN orders.order_id ELSE NULL END) AS brand_orders,
COUNT(CASE WHEN website_sessions.utm_source IS NULL AND website_sessions.http_referer IS NOT NULL THEN orders.order_id ELSE NULL END) AS organic_orders,
COUNT(CASE WHEN website_sessions.utm_source IS NULL AND website_sessions.http_referer IS NULL THEN orders.order_id ELSE NULL END) AS direct_type_orders

FROM website_sessions
LEFT JOIN orders
ON orders.website_session_id = website_sessions.website_session_id
GROUP BY 1,2;
```
We see the bulk of the website's orders comes from our 'gsearch nonbrand' channel. However, there is still growth in our other channels, which is what we would like to see since organic orders and direct type orders are free traffic.

## Objective 4: Show the overall session-to-order conversion rate trends for the same channels (as above) by quarter

```{sql connection=db, max.print = 30}
SELECT
YEAR(website_sessions.created_at) AS yr,
QUARTER(website_sessions.created_at) AS qtr,

COUNT(CASE WHEN website_sessions.utm_source = 'gsearch' AND website_sessions.utm_campaign = 'nonbrand' THEN orders.order_id ELSE NULL END)
/COUNT(CASE WHEN website_sessions.utm_source = 'gsearch' AND website_sessions.utm_campaign = 'nonbrand' THEN website_sessions.website_session_id ELSE NULL END)  AS g_non_orders,

COUNT(CASE WHEN website_sessions.utm_source = 'bsearch' AND website_sessions.utm_campaign = 'nonbrand' THEN orders.order_id ELSE NULL END)
/COUNT(CASE WHEN website_sessions.utm_source = 'bsearch' AND website_sessions.utm_campaign = 'nonbrand' THEN website_sessions.website_session_id ELSE NULL END) AS b_non_orders,

COUNT(CASE WHEN website_sessions.utm_campaign = 'brand' THEN orders.order_id ELSE NULL END)
/COUNT(CASE WHEN website_sessions.utm_campaign = 'brand' THEN website_sessions.website_session_id ELSE NULL END) AS brand_orders,


COUNT(CASE WHEN website_sessions.utm_source IS NULL AND website_sessions.http_referer IS NOT NULL THEN orders.order_id ELSE NULL END)
/COUNT(CASE WHEN website_sessions.utm_source IS NULL AND website_sessions.http_referer IS NOT NULL THEN website_sessions.website_session_id ELSE NULL END) AS organic_orders,

COUNT(CASE WHEN website_sessions.utm_source IS NULL AND website_sessions.http_referer IS NULL THEN orders.order_id ELSE NULL END)
/COUNT(CASE WHEN website_sessions.utm_source IS NULL AND website_sessions.http_referer IS NULL THEN website_sessions.website_session_id ELSE NULL END) AS direct_type_orders

FROM website_sessions
LEFT JOIN orders
ON orders.website_session_id = website_sessions.website_session_id
GROUP BY 1,2;
```
The previous query was useful to see growth by volume but we also would like to see how the order rate for these channels has grown. Volume doesn't always give us the full picture! Here we see interesting results as the years have gone on. Even though 'gsearch nonbrand' orders dominates by volume, all of our channels are on par with one another as far as getting customers to actually place an order with only the 'direct type' order rate being noticeably lower than the others. Perhaps that is something to look into since we would expect people who are going to the website purposefully to be more than simple 'lookers'.

## Objective 5: Pull monthly trending for revenue and margin by product along with total sales and revenue

```{sql connection=db,max.print = 36}
SELECT
DATE_FORMAT(order_items.created_at, '%Y/%m') AS yr_mo,
products.product_name,
SUM(order_items.price_usd) AS revenue,
SUM(order_items.price_usd - order_items.cogs_usd) AS margin

FROM order_items
LEFT JOIN products
ON order_items.product_id = products.product_id
GROUP BY 1,2
ORDER BY 2,1 ASC;
```
Note that the data is organized by the product name and not by date. I thought it to be a little cleaner than to try to figure out which revenue and margin went with what product just for the sake of putting the data in chronological order. Anyways, both of our products are seasonal with peaks occurring in the holiday season and dips happing in the months that follow. However, for 'The Forever Love Bear' we see a spike in February's due to Valentines day and then back down to the normal marks and continued steady growth. Overall, upward trends in revenue and margin are observed so this is good news.

```{sql connection=db,max.print = 30}
SELECT
DATE_FORMAT(order_items.created_at, '%Y/%m') AS yr_mo,
SUM(order_items.price_usd) AS revenue,
SUM(order_items.price_usd - order_items.cogs_usd) AS margin

FROM order_items
LEFT JOIN products
ON order_items.product_id = products.product_id
GROUP BY 1;
```
Okay, so we know how revenue and margin increase by product over time. How about all together regardless of product? We see the trend we would expect. Highly seasonal patterns, with peaks occurring in the holiday time and drop downs immediately after as people work to pay off their credit cards for all the purchases. We do see linear growth over the long run, even with the peaks and troughs, indicating consistent growth over the long term.

## Objective 6: Let's dive deeper into the impact of introducing new products

**Pull monthly sessions to the /products page and show how the % of those sessions clicking through to another page has changed over time along with a view of how conversion from /products to placing an order has changed**

This is a multistep problem. We could embed multiple subqueries but that can be difficult to follow and figure out. Instead, lets break it down step by step. 

First, we need to get the order id for each and every website session along with the date. We will create a `VIEW` for this instead of subquerying to make life easier for us.
```{sql eval=FALSE, connection=db, include=TRUE, max.print = 30}
CREATE VIEW orders_sessions
AS

SELECT
website_sessions.website_session_id,
orders.order_id,
DATE(website_sessions.created_at)

FROM website_sessions
LEFT JOIN orders
ON orders.website_session_id = website_sessions.website_session_id;
```
Here is a preview of what information this view gives:
```{sql echo=FALSE, connection=db, max.print = 30}
SELECT
website_sessions.website_session_id,
orders.order_id,
DATE(website_sessions.created_at)

FROM website_sessions
LEFT JOIN orders
ON orders.website_session_id = website_sessions.website_session_id;
```
Notice multiple NA's for when someone viewed the site but no order was placed. That is exactly what we want to know for our next query.


Next we will create another `VIEW` with the session and order information, including the date, as well as binary indicators for whether they made it to the page after the product page (which is the specific product's page) and then to the order confirmation page. 

```{sql eval=FALSE, connection=db, include=TRUE}
CREATE VIEW prod_order_view
AS
SELECT
orders_sessions.created_at,
orders_sessions.website_session_id,

MAX(CASE WHEN website_pageviews.pageview_url IN ('/the-original-mr-fuzzy','/the-forever-love-bear','/the-birthday-sugar-panda',
'/the-hudson-river-mini-bear') THEN 1 ELSE 0 END) AS next_pg,
MAX(CASE WHEN website_pageviews.pageview_url = '/thank-you-for-your-order' THEN 1 ELSE 0 END) AS order_conf

FROM orders_sessions
LEFT JOIN website_pageviews
ON orders_sessions.website_session_id = website_pageviews.website_session_id
GROUP BY 1,2
HAVING MAX(CASE WHEN website_pageviews.pageview_url = '/products' THEN 1 ELSE 0 END) = 1;
```

This `VIEW` looks as follows:

```{sql echo=FALSE, connection=db}
SELECT
orders_sessions.created_at,
orders_sessions.website_session_id,

MAX(CASE WHEN website_pageviews.pageview_url IN ('/the-original-mr-fuzzy','/the-forever-love-bear','/the-birthday-sugar-panda',
'/the-hudson-river-mini-bear') THEN 1 ELSE 0 END) AS next_pg,
MAX(CASE WHEN website_pageviews.pageview_url = '/thank-you-for-your-order' THEN 1 ELSE 0 END) AS order_conf

FROM orders_sessions
LEFT JOIN website_pageviews
ON orders_sessions.website_session_id = website_pageviews.website_session_id
GROUP BY 1,2
HAVING MAX(CASE WHEN website_pageviews.pageview_url = '/products' THEN 1 ELSE 0 END) = 1;
```



```{sql connection=db, max.print = 30}
SELECT
DATE_FORMAT(created_at, '%Y/%m') AS yr_mo,
COUNT(website_session_id) AS product_sessions,
COUNT(CASE WHEN next_pg = 1 THEN website_session_id ELSE NULL END) AS next_pg,
COUNT(CASE WHEN next_pg = 1 THEN website_session_id ELSE NULL END)/COUNT(website_session_id) AS ctr_nextpg,
COUNT(CASE WHEN order_conf = 1 THEN website_session_id ELSE NULL END) AS orders,
COUNT(CASE WHEN order_conf = 1 THEN website_session_id ELSE NULL END)/COUNT(website_session_id) AS prod_to_order_CVR

FROM prod_order_view
GROUP BY 1;
```
This query shows the number of sessions where a user made it to the '/products' page and then the tunnel of click-through rates beginning at the '/products' and going to the next page in the order process. The last column shoes the conversion rate for those who made it tho the '/products' page and went on to place an order at the end. We see an upward trend in click-through rates as well as order rates. You may argue that product session volume is slightly seasonal with a little bump happing around the holiday time. But, the click-through rate and the order rate both have non seasonal growth, indicating that no matter the time of year people are more and more likely to get further in thr order process as time goes on.


## Objective 7: Pull sales data since then to show how well each product cross sells from the others

Note: The fourth product was made available as a primary product on December 5th, 2014 (it was only available as a cross sell product before then)

```{sql eval=FALSE, connection=db, include=TRUE, max.print = 30}
CREATE VIEW cross_sell
AS

SELECT
orders.order_id,
orders.primary_product_id,
order_items.product_id,
DATE(orders.created_at)

FROM orders
LEFT JOIN order_items
ON orders.order_id = order_items.order_id
AND order_items.is_primary_item = 0
WHERE orders.created_at >= '2014-12-05';
```
Here is a preview of what this view gives:
```{sql echo=FALSE, connection=db, max.print = 30}
SELECT
orders.order_id,
orders.primary_product_id,
order_items.product_id,
DATE(orders.created_at) AS date

FROM orders
LEFT JOIN order_items
ON orders.order_id = order_items.order_id
AND order_items.is_primary_item = 0
WHERE orders.created_at >= '2014-12-05';
```
Notice we have information on the other item that was sold as part of this order. How can we visualize this a little better to get a grasp on how each product cross sells with each other?
```{sql connection=db, max.print = 30}
SELECT
primary_product_id,
COUNT(primary_product_id) AS as_primary_product,
COUNT(CASE WHEN product_id = 1 THEN order_id ELSE NULL END) AS X_prod_1,
COUNT(CASE WHEN product_id = 2 THEN order_id ELSE NULL END) AS X_prod_2,
COUNT(CASE WHEN product_id = 3 THEN order_id ELSE NULL END) AS X_prod_3,
COUNT(CASE WHEN product_id = 4 THEN order_id ELSE NULL END) AS X_prod_4,

COUNT(CASE WHEN product_id = 1 THEN order_id ELSE NULL END)/COUNT(primary_product_id) AS X_prod_1_rt,
COUNT(CASE WHEN product_id = 2 THEN order_id ELSE NULL END)/COUNT(primary_product_id) AS X_prod_2_rt,
COUNT(CASE WHEN product_id = 3 THEN order_id ELSE NULL END)/COUNT(primary_product_id) AS X_prod_3_rt,
COUNT(CASE WHEN product_id = 4 THEN order_id ELSE NULL END)/COUNT(primary_product_id) AS X_prod_4_rt
FROM cross_sell
GROUP BY 1
ORDER BY primary_product_id ASC;
```
Here is some really interesting advanced data analytics! We have created cross sell analysis matrices to see how the products perform as cross sell options relative to a primary product, both by volume and by rate. All products cross sell product 4 the best, getting over 20% of users to add on the product to their order. Product 4, since it obviously cannot cross sell with itself, doesn't cross sell particularly well with any product with product three being the highest rate at about 3.8%. 