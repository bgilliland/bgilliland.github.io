---
title: "SQL: Data Analytics For an Online Retailer Part 1"
date: "2020-05-21"
tags: [MySQL, MySQL Workbench, R Studio, R Markdown, RMariaDB]
excerpt: "Analyzing Traffic Sources, Analyzing Website Performance"
mathjax: true
output: github_document
---

## Background

I completed Maven Analytic's 'Advanced SQL + MySQL for Analytics & Business Intelligence' course. During this course there were 2 projects we were to complete to get simulated experience with not only the advanced SQL skills taught in the body of the course but also in the context of a business setting. The relational database, mavenfuzzyfactory, was imported into MySQL Workbench and used throughout the course. 

I played the role of a data analyst for a new online retailer, Maven Fuzzy Factory. They make stuffed animals. In this database, we had info dealing with website sessions, website pageviews, products, orders, order items, and refunds. The board of directors and executives needed answers to some questions to see if the business was growing and doing so efficiently.

The analysis was performed in MySQL Workbench and the reporting as follows was done using an R Markdown file in R Studio by connecting to the database using the `RMariaDB` R Package and using SQL chunks.

**SQL Concepts Implemented**

* The Big 6: `SELECT`-->`FROM`-->`WHERE`-->`GROUP BY`-->`HAVING`-->`ORDER BY`
* Aggregation (`COUNT`, `SUM`, `MAX`, ect.)
* `LEFT JOIN`
* `VIEW`'s and Subqueries
* `CASE` and `COUNT(DISTINCT CASE WHEN...)` (count-case pivoting)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RMariaDB)
library(knitr)
# Connect to MySQL Database
db <- dbConnect(RMariaDB::MariaDB(), user='R_fuzzy',password="Mathematic$1998", dbname='mavenfuzzyfactory', host='localhost',bigint = "numeric")
# List the tables in our relational database
dbListTables(db)
```

## Midterm Project

**Note: These queries will show only a limited number of rows for the sake of seeing the structure of the output. They are not the full result of the queries in terms of number of rows**

Some of the types of inquiries and requests I recieved involve:

* Analyzing Traffic Sources (Conversion Rates, Bid Optimization, Traffic Source Trending)
* Analyzing Website Performance (Analyzing Top Pages & Entry Pages, Bounce Rates & Landing Page Tests, Landing Page Trend Analysis, Conversion Funnels & Testing Conversion Paths)

## Objective 1: Order Conversion Rate Trending

**Pull monthly trends for ‘gsearch' sessions and ‘orders’ so that we can showcase Order Rate growth** (In terms of Website Session volume, Order volume, and Conversion Rate)

(Note: ‘gsearch’ is a UTM parameter that indicates if a potential
customer found the website via the ‘gsearch’ search engine)

```{sql connection=db, max.print=15}
SELECT
DATE_FORMAT(website_sessions.created_at, '%Y/%m') AS yr_mo,

COUNT(DISTINCT website_sessions.website_session_id) AS sessions,
COUNT(DISTINCT orders.order_id) AS orders,
COUNT(DISTINCT orders.order_id)/COUNT(DISTINCT website_sessions.website_session_id) AS order_rate

FROM website_sessions
LEFT JOIN orders
ON website_sessions.website_session_id = orders.website_session_id
WHERE website_sessions.utm_source = 'gsearch'
GROUP BY 1;
```

***Evidently our Session volume and Conversion Rate has been increasing
steadily since the inception of the business, exactly what we would want
to see.***



## Objective 2: Order Conversion Rate Trending by Advertising Campaign 

**Get a monthly Order Rate trend for ‘gsearch’ but this time split out ‘nonbrand’ and ‘brand’ campaigns** (In terms of Website Session volume, Order volume, and Conversion Rate)

(Note: The ‘brand’ and ‘nonbrand’ campaigns are paid advertisements)

```{sql, connection=db, max.print = 15}
SELECT
DATE_FORMAT(website_sessions.created_at, '%Y/%m') AS yr_mo,

COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'brand' THEN website_sessions.website_session_id ELSE NULL END) AS brand_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'brand' THEN orders.order_id ELSE NULL END) AS brand_orders,
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'brand' THEN orders.order_id ELSE NULL END)/
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'brand' THEN website_sessions.website_session_id ELSE NULL END) AS brand_order_rt,
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'nonbrand' THEN website_sessions.website_session_id ELSE NULL END) AS nonbrand_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'nonbrand' THEN orders.order_id ELSE NULL END) AS nonbrand_orders,
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'nonbrand' THEN orders.order_id ELSE NULL END)/
COUNT(DISTINCT CASE WHEN website_sessions.utm_campaign = 'nonbrand' THEN website_sessions.website_session_id ELSE NULL END) AS nonbrand_order_rt

FROM website_sessions
LEFT JOIN orders
ON website_sessions.website_session_id = orders.website_session_id
WHERE website_sessions.utm_source = 'gsearch'
GROUP BY 1;
```

***Brand sessions have been increasing but the Conversion Rate has been
volatile with an over all upward trend. Nonbrand sessions have had
significant growth in Website Sessions peaking around November/December
of 2012 and settling in the 4000-5000 range. They have observed consistent growth in Conversion Rate, nearing the 7% mark in latter months.***

## Objective 3: Order Conversion Rate Trending by Device Type

**While on ‘gsearch’, dive into ‘nonbrand’ and pull volumes for Monthly Sessions and Orders along with Conversion Rates split by Device Type (‘mobile’, ‘desktop’)**

```{sql, connection=db, max.print = 15}
SELECT
DATE_FORMAT(website_sessions.created_at, '%Y/%m') AS yr_mo,

COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'desktop' THEN website_sessions.website_session_id ELSE NULL END) AS desktop_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'desktop' THEN orders.order_id ELSE NULL END) AS desktop_orders,
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'desktop' THEN orders.order_id ELSE NULL END)/
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'desktop' THEN website_sessions.website_session_id ELSE NULL END) AS desktop_order_rt,
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'mobile' THEN website_sessions.website_session_id ELSE NULL END) AS mobile_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'mobile' THEN orders.order_id ELSE NULL END) AS mobile_orders,
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'mobile' THEN orders.order_id ELSE NULL END)/
COUNT(DISTINCT CASE WHEN website_sessions.device_type = 'mobile' THEN website_sessions.website_session_id ELSE NULL END) AS mobile_order_rt

FROM website_sessions
LEFT JOIN orders
ON website_sessions.website_session_id = orders.website_session_id
WHERE website_sessions.utm_source = 'gsearch' AND website_sessions.utm_campaign = 'nonbrand'
GROUP BY 1;
```
***We see fast growth in desktop orders early on and slower growth late,
but with consistent growth in order rate throughout. Mobile order
sessions are volatile all around but have had fewer drop offs in recent
months. There is consistent growth with their order rates despite the
volatility in session volume.***

## Objective 4: Order Conversion Rate Trending by Website Channel Type

**Pull monthly trends by volume and Order Conversion Rate for ‘gsearch’ alongside each of our other channels**

(Note: If it is a ‘bsearch’ or ‘gsearch’ session, then they got to the website via
search engine by clicking on a paid advertisement. If it was through a
search engine but instead of a paid advertisement they clicked on a
normal link, then that is an ‘organic session’. If they directly typed
in the website’s http address then it is a ‘direct session’.)
```{sql connection=db, max.print = 15}
SELECT
DATE_FORMAT(website_sessions.created_at, '%Y/%m') AS yr_mo,

COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'gsearch' THEN website_sessions.website_session_id ELSE NULL END) AS gsearch_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'gsearch' THEN orders.order_id ELSE NULL END) AS gsearch_orders,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'gsearch' THEN orders.order_id ELSE NULL END)/
COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'gsearch' THEN website_sessions.website_session_id ELSE NULL END) AS gsearch_order_rt,

COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'bsearch' THEN website_sessions.website_session_id ELSE NULL END) AS bsearch_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'bsearch' THEN orders.order_id ELSE NULL END) AS bsearch_orders,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'bsearch' THEN orders.order_id ELSE NULL END)/
COUNT(DISTINCT CASE WHEN website_sessions.utm_source = 'bsearch' THEN website_sessions.website_session_id ELSE NULL END) AS bsearch_order_rt,

COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NOT NULL THEN website_sessions.website_session_id ELSE NULL END) AS organic_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NOT NULL THEN orders.order_id ELSE NULL END) AS organic_orders,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NOT NULL THEN orders.order_id ELSE NULL END)
/COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NOT NULL THEN website_sessions.website_session_id ELSE NULL END) AS organic_order_rt,

COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NULL THEN website_sessions.website_session_id ELSE NULL END) AS direct_sessions,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NULL THEN orders.order_id ELSE NULL END) AS direct_orders,
COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NULL THEN orders.order_id ELSE NULL END)
/COUNT(DISTINCT CASE WHEN website_sessions.utm_source IS NULL AND http_referer IS NULL THEN website_sessions.website_session_id ELSE NULL END) AS direct_order_rt

FROM website_sessions
LEFT JOIN orders
ON website_sessions.website_session_id = orders.website_session_id
GROUP BY 1;
```
***We see steady growth across the board with ‘direct’ sessions and
‘organic’ sessions having the most impressive conversion rates. This
makes sense since those users were seeking out specifically our company.
However, the vast majority of the traffic comes from ‘bsearch’ and
‘gsearch’.***

## Objective 5: Estimating Order Volume Differential

**Estimate the additional orders we have recieved as a result from switching from ‘/home’ to ‘/lander-1’ (June 19 to July 28) as the landing page for ‘gsearch nonbrand’ sessions** 

(Note: here, these url’s represent the first page a user sees when they
get to the site)

This is a multistep problem. First, we need to get the differential in order rates between the two landing pages. This will require using a subquery and the following query will be the inner query imbedded in the `FROM` statement:

```{sql connection=db, max.print = 15}
SELECT 
website_sessions.website_session_id,
website_pageviews.pageview_url,

MIN(website_pageviews.website_pageview_id) AS land_pg_view_id

FROM website_sessions
LEFT JOIN website_pageviews
ON website_sessions.website_session_id = website_pageviews.website_session_id
WHERE website_sessions.created_at BETWEEN '2012-06-19' AND '2012-07-28' 
AND website_sessions.utm_source = 'gsearch'
AND website_sessions.utm_campaign = 'nonbrand'
AND website_pageviews.pageview_url IN ('/home','/lander-1')
GROUP BY 1,2;
```
Now we know what url was the landing page for each website session. Let's get the order rates for our two landing url's:
```{sql connection=db}
SELECT DISTINCT
land_pg.pageview_url,

COUNT(DISTINCT land_pg.website_session_id) AS sessions,
COUNT(DISTINCT orders.order_id) AS orders,
COUNT(DISTINCT orders.order_id)/COUNT(DISTINCT land_pg.website_session_id) AS order_rt

FROM (
SELECT 
website_sessions.website_session_id,
website_pageviews.pageview_url,

MIN(website_pageviews.website_pageview_id) AS land_pg_view_id

FROM website_sessions
LEFT JOIN website_pageviews
ON website_sessions.website_session_id = website_pageviews.website_session_id
WHERE website_sessions.created_at BETWEEN '2012-06-19' AND '2012-07-28' 
AND website_sessions.utm_source = 'gsearch'
AND website_sessions.utm_campaign = 'nonbrand'
AND website_pageviews.pageview_url IN ('/home','/lander-1')
GROUP BY 1,2
) AS land_pg

LEFT JOIN orders
ON orders.website_session_id = land_pg.website_session_id
GROUP BY 1;
```
***Evidently ‘/lander-1’ outperforms ‘/home’ by about .0088 orders per
session.***

We would like to see when the last time was that ‘/home’ was used as a
landing page. This will give us our cutoff point for the next query when
we get the total number of ‘/lander-1’ sessions.
```{sql connection=db}
SELECT
MAX(website_sessions.website_session_id) AS max_session_id

FROM website_sessions
LEFT JOIN website_pageviews
ON website_sessions.website_session_id = website_pageviews.website_session_id
WHERE website_sessions.utm_source = 'gsearch'
AND website_sessions.utm_campaign = 'nonbrand'
AND website_pageviews.pageview_url = '/home';
```
***So the last ‘/home’ session was at the 17145th website session.***

Now we will get the number of ‘/lander-1’ sessions
```{sql connection=db}
SELECT
COUNT(website_sessions.website_session_id) AS session_count

FROM website_sessions
LEFT JOIN website_pageviews
ON website_sessions.website_session_id = website_pageviews.website_session_id
WHERE website_sessions.utm_source = 'gsearch'
AND website_sessions.website_session_id > 17145
AND website_sessions.utm_campaign = 'nonbrand'
AND website_pageviews.pageview_url = '/lander-1';
```

***35,734 sessions X .0088 differential =\> 314 more orders with
‘/lander-1’ than what would’ve been with ‘/home’. Evidence that
‘lander-1’ is in the best interest of the company to use as the
landing page for the
website.***

## Objective 6: Conversion Tunnel Comparison

**Create full conversion tunnels for both the ‘/home’ and ‘/lander-1’ (‘gsearch nonbrand’)**

(Note: This conversion tunnel takes you through each necessary page in
order to reach a completed order. We would like to compare the tunnels
of the ‘/home’ and ‘/lander-1’ landing pages beginning on June 19, 2012
(since that is when ‘/lander-1’ was first created.)

This will also be a multistep problem. If we really wanted to, we could do this by embedding multiple subqueries. However, that can be difficult to read for someone else who didn't write the code but also for the one who wrote it who may need to refer back to it later. Instead we can make use of `VIEW`'s in SQL that store queries that we can access later by using `SELECT` statements on them like we would on a table like so:

```{sql eval=FALSE, connection=db, include=TRUE}
CREATE VIEW home_monthly_conv
AS
SELECT
website_sessions.created_at,
website_sessions.website_session_id,

CASE WHEN website_pageviews.pageview_url = '/home' THEN 1 ELSE 0 END AS home,
CASE WHEN website_pageviews.pageview_url = '/lander-1' THEN 1 ELSE 0 END AS lander,
CASE WHEN website_pageviews.pageview_url = '/products' THEN 1 ELSE 0 END AS prod,
CASE WHEN website_pageviews.pageview_url = '/the-original-mr-fuzzy' THEN 1 ELSE 0 END AS fuzzy,
CASE WHEN website_pageviews.pageview_url = '/cart' THEN 1 ELSE 0 END AS cart,
CASE WHEN website_pageviews.pageview_url = '/shipping' THEN 1 ELSE 0 END AS ship,
CASE WHEN website_pageviews.pageview_url IN ('/billing','/billing-2') THEN 1 ELSE 0 END AS bill,
CASE WHEN website_pageviews.pageview_url = '/thank-you-for-your-order' THEN 1 ELSE 0 END AS thanks_last

FROM website_pageviews
LEFT JOIN website_sessions
ON website_sessions.website_session_id = website_pageviews.website_session_id
WHERE website_pageviews.created_at > '2012-06-19' 
AND website_sessions.website_session_id < 17145
AND website_sessions.utm_campaign = 'nonbrand'
AND website_sessions.utm_source = 'gsearch';

```
This `VIEW` looks like this: 

```{sql echo=FALSE, connection=db}
SELECT
website_sessions.created_at,
website_sessions.website_session_id,

CASE WHEN website_pageviews.pageview_url = '/home' THEN 1 ELSE 0 END AS home,
CASE WHEN website_pageviews.pageview_url = '/lander-1' THEN 1 ELSE 0 END AS lander,
CASE WHEN website_pageviews.pageview_url = '/products' THEN 1 ELSE 0 END AS prod,
CASE WHEN website_pageviews.pageview_url = '/the-original-mr-fuzzy' THEN 1 ELSE 0 END AS fuzzy,
CASE WHEN website_pageviews.pageview_url = '/cart' THEN 1 ELSE 0 END AS cart,
CASE WHEN website_pageviews.pageview_url = '/shipping' THEN 1 ELSE 0 END AS ship,
CASE WHEN website_pageviews.pageview_url IN ('/billing','/billing-2') THEN 1 ELSE 0 END AS bill,
CASE WHEN website_pageviews.pageview_url = '/thank-you-for-your-order' THEN 1 ELSE 0 END AS thanks_last

FROM website_pageviews
LEFT JOIN website_sessions
ON website_sessions.website_session_id = website_pageviews.website_session_id
WHERE website_pageviews.created_at > '2012-06-19' 
AND website_sessions.website_session_id < 17145
AND website_sessions.utm_campaign = 'nonbrand'
AND website_sessions.utm_source = 'gsearch';
```

1's represent if that session id ever made it to that page. What we would like to do is see this as a funnel, in other words not having seperate rows for each distinct session id so that we can see where the funnel stops more easily. We can do this as follows, making use of our view:

```{sql connection=db}
SELECT
website_session_id,

MAX(home) AS home_pg,
MAX(lander) AS lander_pg,
MAX(prod) AS prod,
MAX(fuzzy) AS fuzzy,
MAX(cart) AS cart,
MAX(ship) AS ship,
MAX(bill) AS bill,
MAX(thanks_last) AS thanks

FROM home_monthly_conv
GROUP BY 1;
```
This is exactly what we wanted. We can clearly see which lander was used for each session and then how they traversed the next several pages. Since this query isn't too complicated, let's use it as a subquery instead of making another `VIEW`, although that would definitely be a valid approach. We will use this as a subquery to get our counts and rates for each step in the order funnel depending on what their lander was. This final query is as follows:


```{sql connection=db}
SELECT
CASE 
	  WHEN home_pg = 1 THEN 'home'
    WHEN lander_pg = 1 THEN 'lander'
    ELSE 'something else' 
END AS landers,

COUNT(DISTINCT website_session_id) AS sessions,
COUNT(DISTINCT CASE WHEN prod = 1 THEN website_session_id ELSE NULL END) AS product_pg,
COUNT(DISTINCT CASE WHEN fuzzy = 1 THEN website_session_id ELSE NULL END) AS fuzzy_pg,
COUNT(DISTINCT CASE WHEN cart = 1 THEN website_session_id ELSE NULL END) AS cart_pg,
COUNT(DISTINCT CASE WHEN ship = 1 THEN website_session_id ELSE NULL END) AS ship_pg,
COUNT(DISTINCT CASE WHEN bill = 1 THEN website_session_id ELSE NULL END) AS bill_pg,
COUNT(DISTINCT CASE WHEN thanks = 1 THEN website_session_id ELSE NULL END) AS order_pg

FROM(
SELECT
website_session_id,

MAX(home) AS home_pg,
MAX(lander) AS lander_pg,
MAX(prod) AS prod,
MAX(fuzzy) AS fuzzy,
MAX(cart) AS cart,
MAX(ship) AS ship,
MAX(bill) AS bill,
MAX(thanks_last) AS thanks

FROM home_monthly_conv
GROUP BY 1

) AS funnel_table
GROUP BY 1;
```
***It is evident that ‘/lander-1’ has had better
stepthrough’s than ‘/home’. This indicates to us that we should move forward with featuring the ‘/lander-1’ landing page.***

## Objective 7: Analyzing Revenue per Session  

**Quantify the impact of the billing test (‘/billing’ vs. ‘/billing-2’) by analyzing the lift generated from the test (Sept 10 to Nov 10) in terms of revenue per billing page session**

We will once again make use of a subquery to get our desired information. 

```{sql connection=db}
SELECT 
website_pageviews.created_at,
website_pageviews.website_session_id,
website_pageviews.pageview_url,
orders.order_id,
orders.price_usd

FROM website_pageviews
LEFT JOIN orders
ON orders.website_session_id = website_pageviews.website_session_id
WHERE website_pageviews.created_at BETWEEN '2012-09-10' AND '2012-11-10'
AND website_pageviews.pageview_url IN ('/billing','/billing-2');
```
Here we have information concerning when a purchase was made, which session it is associated with, what billing page they used (key information), and then the order info as well. We can use this now to compare the two billing pages to see which had better perfomance as follows:

```{sql connection=db}
SELECT DISTINCT
pageview_url,

COUNT(website_session_id) AS billing_sessions,
COUNT(order_id) AS orders,
SUM(price_usd)/COUNT(pageview_url) AS rev_per_session

FROM(
SELECT 
website_pageviews.created_at,
website_pageviews.website_session_id,
website_pageviews.pageview_url,
orders.order_id,
orders.price_usd

FROM website_pageviews
LEFT JOIN orders
ON orders.website_session_id = website_pageviews.website_session_id
WHERE website_pageviews.created_at BETWEEN '2012-09-10' AND '2012-11-10'
AND website_pageviews.pageview_url IN ('/billing','/billing-2')

) AS billing_pg
GROUP BY 1;
```
***The billing test indicates that the second billing page-type, '/billing-2' is more effective in converting more orders. There is more orders by volume and also more money being spent persession as a result.***